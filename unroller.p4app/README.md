
# Unroller.p4app

The core part of P4 implementation of Unroller is situated in the `unroller.p4` file. It also includes other files from `includes/` defining parser, deparser, metadata or headers data structures.

Configuration file `p4app.json` defines the application in the environment of p4app tool. This file extends the standard enviroment using a custom implementation of AppController and AppProcRunner classes. Standard configuration options including the ways how to override the default controller and runner are described in the original p4app Github repository (https://github.com/p4lang/p4app).

Custom classes in `customization.py` file enables to start a tool which simulates a switch controller. The tool `tools/digest_client.py` reads and prints digest messages generated by the switch running Unroller. It utilizes `tools/bmpy_utils.py` (https://github.com/p4lang/behavioral-model/blob/master/tools/bmpy_utils.py) the original Python API of BMv2 switch implementation to communicate with the switch using the thrift interface. Finally, the custom controller implementation executes also the tool `packet_generator.py` to generate an initial packet entering the first switch. The tool than captures the output of the switch (packet with modified Unroller header) and uses it as an input for the next switch on the configured path.

You can edit parameters of the loop / path or the algorithm at the beginning of `customization.py` file:

```
# List of switch IDs visited before the loop
UNROLLER_B = [1]

# List of switch IDs of the loop
UNROLLER_L = [6, 3, 2, 7]

# The threshold for reporting a loop
UNROLLER_TH = 1
```

Lexi's code annotations: 
```
unroller.config

mc_mgrp_create 1  #creates a multicast group with id 1
mc_mgrp_create 2  #creates a multicast group with id 2
mc_node_create 0 1 #creates a multicast node with rid value 0 and gives it port 1 
mc_node_create 1 2 #rid 1, port 2
mc_node_associate 1 1 #associates node 1 to multicast group 1
mc_node_associate 2 0 #associates node 0 to multicast group 2
register_write cfg_swid_reg 0 0  #register write allows you to write a value into an indexed instance of a register which here is called cfg_switd_reg
register_write cfg_thcnt_reg 0 1
```

From headers.p4
```
header unroller_head_t {
    bit<16> etherType;  
    bit<16> hopid; 
    bit<8> thcnt; #value of the threshold counter
    bit<8> swids; #switch ids currently seen 
}
```
